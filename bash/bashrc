## Exports
export EDITOR=vim


## Prompt
export PS1='\w$(parse_git_status)$ '


## Functions

# Get git repository status in shorthand form. Condensed form of:
# https://github.com/magicmonty/bash-git-prompt
function parse_git_status () {

  local -a git_status=($(source "$__BASH_SOURCE_DIR/bash_git_prompt" 2>/dev/null))

  local branch="${git_status[0]}"
  local remote="${git_status[1]}"
  local staged="${git_status[2]}"
  local conflicts="${git_status[3]}"
  local changed="${git_status[4]}"
  local untracked="${git_status[5]}"
  local stashed="${git_status[6]}"

  local flags=""

  local branch_text_color="3"      # yellow
  local branch_ahead_color="2"     # green
  local branch_behind_color="1"    # red

  local flags_conflicts_color="1"  # red
  local flags_stashed_color="6"    # cyan
  local flags_todos_color="5"      # magenta
  local flags_untracked_color="5"  # magenta
  local flags_changed_color="5"    # magenta
  local flags_staged_color="2"     # green

  local open_color="\001\033[3"
  local close_color="m\002"

  branch_text_color="$open_color$branch_text_color$close_color"
  branch_ahead_color="$open_color$branch_ahead_color$close_color"
  branch_behind_color="$open_color$branch_behind_color$close_color"

  flags_conflicts_color="$open_color$flags_conflicts_color$close_color"
  flags_stashed_color="$open_color$flags_stashed_color$close_color"
  flags_todos_color="$open_color$flags_todos_color$close_color"
  flags_untracked_color="$open_color$flags_untracked_color$close_color"
  flags_changed_color="$open_color$flags_changed_color$close_color"
  flags_staged_color="$open_color$flags_staged_color$close_color"

  # Test for initialized git repository; otherwise, bail.
  if [ -n "$branch" ] && [ "$branch" != "_PREHASH_" ]; then
    if [ -n "$remote" ] && [ "$remote" != "_NO_REMOTE_TRACKING_" ]; then
      local tracking=" ⥮"
      if [ "$remote" != "." ]; then
        remote=${remote//_AHEAD_/${branch_ahead_color} ▲}
        remote=${remote//_BEHIND_/${branch_behind_color} ▼}
        tracking="$tracking$remote"
      fi
    fi
    echo -en "$branch_text_color ⎇ ${branch}${tracking}"
  else
    return
  fi

  if [ "$conflicts" != "0" ]; then
    flags="${flags}${flags_conflicts_color} ✗${conflicts}"
  fi

  if [ "$stashed" != "0" ]; then
    flags="${flags}${flags_stashed_color} ⚑${stashed}"
  fi

  # Count any TODOs in project files.
  local todos="$(git grep -F 'TODO' | wc -l | bc)"
  if [ "$todos" != "0" ]; then
    flags="${flags}${flags_todos_color} ✓${todos}"
  fi

  if [ "$staged" != "0" ]; then
    flags="${flags}${flags_staged_color} ●${staged}"
  fi

  if [ "$changed" != "0" ]; then
   flags="${flags}${flags_changed_color} ●${changed}"
  fi

  if [ "$untracked" != "0" ]; then
    flags="${flags}${flags_untracked_color} ○${untracked}"
  fi

  if [ -n "$flags" ]; then
    echo -en "${flags}"
  fi

  # Reset colors.
  echo -en "\001\033[0m\002 "

}

# Open SSH sessions in new tmux window and connect to a nested tmux session.
function tmux_ssh () {
  if [ -n "$2" ]; then
    if [ "$1" = "-notmux" ]; then
      shift
    fi
    ssh "$@"
  else
    tmux new-window -n "$1" """ssh -t "$1" '(command -v tmux >/dev/null 2>&1 && (tmux attach || tmux new-session -s ssh)) || bash -l'""" && tmux_food
  fi
}
alias ssh="tmux_ssh"
alias pssh="tmux_ssh -notmux"

# Change to directory of the frontmost Finder window.
function cdf () {
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Find the target of a redirecting URL.
function expandurl () {
# wget -S $1 2>&1 | grep ^Location;
  curl -sIL $1 | grep '^Location' | tail -n 1 | awk '{print $2}'
}

# Change git remote by supplying user/repo.
function gitremote () {
  if [ -d ".git" ] && [ -n "$1" ]; then
    git remote rm origin
    git remote add origin git@github.com:${1}.git
    git config master.remote origin
    git config master.merge refs/heads/master
    echo "Updated git remote to git@github.com:${1}.git"
  else
    echo "Not a git repository."
  fi
}

# Get actual path to this directory for non-symlinked resources.
# http://stackoverflow.com/questions/59895
function get_bash_source_dir () {
  local SOURCE="${BASH_SOURCE[0]}"
  while [ -h "$SOURCE" ]; do
    local DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  echo "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
}


## Variables

__BASH_SOURCE_DIR="$(get_bash_source_dir)"
